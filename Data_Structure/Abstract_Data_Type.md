# 1. Abstract Data Type (추상 자료형)

## 기능 vs 구현

기능은 연산이 무엇을 하는지에 관한 내용이다. '무엇'에 대한 약속이라 할 수 있다.<br>
삽입 연산 기능: 순서 데이터에서 원하는 위치에 데이터를 저장

구현은 연산의 기능을 어떻게 할지에 대한 설명이다. 연신의 기능을 '어떻게' 하는지에 대한 구체적 설명이라 할 수 있다.<br>
(동적 배열 삽입, 링크드 리스트 삽입)
<br><br>

## 추상화

추상화는 어떻게 구현되어 있는지 몰라도 기능만 알면 사용할 수 있게 해주는 것을 말한다. <br>
추상화를 하면 이미 쓴 코드를 재활용하고 협력하기 쉬워진다.
<br><br>

### 추상 자료형

자료 구조를 추상화한 걸 추상 자료형이라 한다. <br>
데이터를 정확히 어떻게 저장하고 저장한 데이터를 어떻게 가져오는지에 대해 신경쓰지 않고 오직 기능만으로 데이터를 다룰 수 있게 해준다.
<br><br>

### 추상 자료형 vs 자료 구조

<br>

**리스트** (추상 자료형)

- 데이터 간 순서 관계를 유지할 수 있다.
- 접근 연산: 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
- 탐색 연산: 특정 조건을 만족하는 데이터를 찾는다.
- 삽입 연산: 특정 위치에 새로운 데이터를 저장한다.
- 삭제 연산: 특정 위치에 있는 데이터를 지운다.

리스트는 데이터에 접근, 탐색, 삽입, 삭제 연산을 할 수 있는 추상 자료형이다. <br>
이 연산들을 정확히 어떻게 구현할 건지에 대한 내용은 추상 자료형에 포함되지 않는다.

<br>

**동적 배열** (자료 구조)

- 데이터를 메모리에 순서대로 그리고 연속적으로 저장한다.
- 접근 연산: 인덱스 주소를 한 번에 계산해서 메모리에 접근한다.
- 탐색 연산: 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다.
- 삽입 연산: 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다.
- 삭제 연산: 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다.

자료 구조는 데이터를 정확히 어떻게 저장할 건지 데이터 간 관계를 어떻게 유지할 건지 각 연산들을 구체적으로 어떻게 할지 이 모든 것을 묶어 놓은 개념이다. <br>
이처럼 자료 구조는 구체적으로 구현까지 포함한 내용이다.
<br><br>

동적 배열은 리스트의 모든 연산들을 갖고 있는 자료 구조이다. <br>
이때 '리스트는 동적 배열로 구현할 수 있다'라고 표현한다. <br>

기능을 중점적으로 얘기하고 싶을 때나, 흐름을 생각할 때와 같이 구현에 집중할 필요가 없을 때 추상 자료형을, 그리고 코드의 성능을 분석하거나 최적화 시켜야 될 때나 (성능을 최대로 끌어올리고 싶을 때) 자료 구조를 중심적으로 생각하면 된다.

<br>

**리스트 개념**

```python
# 파이썬 리스트 생성
trending = []

# 특정 위치에 데이터 삽입
trending.insert(0, "연예인 A씨")
trending.insert(1, "잠실 콘서트")
trending.insert(2, "한국 휴일 수")
trending.insert(3, "추석 음식")

print(trending) # 리스트 출력

# 괄호를 이용한 인덱스 접근
print(trending[0])
print(trending[1])

trending[2] = 4

print(trending)

# in을 이용한 탐색
print("연예인 A씨" in trending)
print("연예인 B씨" in trending)

# del을 이용한 삭제
del trending[0]

print(trending)
```

<br>

**리스트 구현**

| 연산        | 동적 배열      | 더블리 링크드 리스트 |
| ----------- | -------------- | -------------------- |
| 접근        | O(1)           | O(n)                 |
| 탐색        | O(n)           | O(n)                 |
| 접근 + 삽입 | O(n)           | O(n)                 |
| 접근 + 삭제 | O(n)           | O(n)                 |
| ↑↓          | ↑ 일반적 경우  | ↓ 특수한 경우        |
| 맨 앞 삽입  | O(n)           | O(1)                 |
| 맨 앞 삭제  | O(n)           | O(1)                 |
| 맨 뒤 삽입  | 분할 상환 O(1) | O(1)                 |
| 맨 뒤 삭제  | 분할 상환 O(1) | O(1)                 |

<br><br>

**큐(Queue) 개념**

데이터 간 순서를 약속하는 추상 자료형이다. 큐는 한국어로 대기열을 의미한다. <br>
큐는 데이터를 삭제할 때는 가장 앞에서만 삭제하고 삽입할 때는 가장 뒤에서만 삽입해주는 추상 자료형이다. (FIFO: First-In-First-Out)

- 데이터 간 순서 관계를 유지할 수 있다.
- 맨 뒤 데이터 추가
- 맨 앞 데이터 삭제
- 맨 앞 데이터 접근

```python
# deque
# Doubly-ended-queue의 약자
# 더블리 링크드 리스트를 사용하기에 맨 앞 삭제, 맨 뒤 삽입, 맨 앞 접근은 O(1)이다.
# 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형
# deque는 파이썬 collections 모듈에서 가지고 온다.
from collections import deque

queue = deque()

# 큐의 맨 끝에 데이터 삽입
queue.append("사과")
queue.append("바나나")
queue.append("포도")
queue.append("딸기")
queue.append("수박")

print(queue)  # 큐 출력

# 큐의 가장 앞 데이터 접근
print(queue[0])

# 큐 맨 앞 데이터 삭제
print(queue.popleft())
print(queue.popleft())
print(queue.popleft())
```

<br><br>

**큐 구현**

큐는 동적 배열과 링크드 리스트로 구현할 수 있다. <br>
두 자료 구조 모두 데이터 간 순서를 유지하고 특정 위치의 데이터에 접근하거나 삽입, 삭제할 수 있기 때문이다.

|            | 동적 배열      | 더블리 링크드 리스트 |
| ---------- | -------------- | -------------------- |
| 맨 앞 삭제 | O(n)           | O(1)                 |
| 맨 뒤 삽입 | 분할 상환 O(1) | O(1)                 |
| 맨 앞 접근 | O(1)           | O(1)                 |

<br><br>

**스택(stack) 개념**

데이터 간 순서를 약속하는 추상 자료형이다. 스택은 영어로 어떤 물건이 차곡차곡 쌓여 있는 걸 말한다. <br>
데이터를 맨 끝에 추가하고 삭제할 때도 맨 끝에 데이터를 삭제하는 연산을 약속하는 추상 자료형이다. (LIFO: LAST-In-First-Out)<br>

- 데이터 간 순서 관계를 유지할 수 있다.
- 맨 뒤 데이터 추가
- 맨 뒤 데이터 삭제
- 맨 뒤 데이터 접근

```python
# deque
# Doubly-ended-queue의 약자
# 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형
from collections import deque

stack = deque()

# 스택 맨 끝에 데이터 추가
stack.append("a")
stack.append("b")
stack.append("c")
stack.append("d")
stack.append("e")

print(stack)  # 스택 출력

# 스택 맨 끝 데이터 접근
print(stack[-1])

# 맨 끝 데이터 삭제
print(stack.pop())
print(stack.pop())
print(stack.pop())

print(stack)  # 스택 출력
```

<br><br>

**스택 구현**

스택은 동적 배열과 링크드 리스트로 구현할 수 있다. <br>
| | 동적 배열 | 더블리 링크드 리스트 |
| ---------- | -------------- | -------------------- |
| 맨 뒤 삭제 | 분할 상환 O(1) | O(1) |
| 맨 뒤 삽입 | 분할 상환 O(1) | O(1) |
| 맨 뒤 접근 | O(1) | O(1) |

<br><br>

**딕셔너리(Dictionary) 개념**

저장하는 데이터의 순서 관계를 약속하지 않는다.

- 데이터 간 순서 관계를 약속하지 않음
- key - value 데이터 쌍 삽입
- key를 이용한 데이터 탐색
- key를 이용한 데이터 삭제

```python
grades = {}

# key - value 데이터 삽입
grades["AA"] = 80
grades["BB"] = 70
grades["CC"] = 90
grades["DD"] = 60
grades["EE"] = 50

print(grades)  # 딕셔너리 출력

# key를 이용해서 value 탐색
print(grades["AA"])
print(grades["BB"])

# key를 이용한 삭제
grades.pop("AA")
grades.pop("BB")
```

<br>

|                   | 해시 테이블 |
| ----------------- | ----------- |
| key-value 쌍 삽입 | O(1)        |
| key를 이용한 탐색 | O(1)        |
| key를 이용한 삭제 | O(1)        |

<br><br>

**세트(Set) 개념**

- 데이터 간 순서 관계를 약속하지 않음
- 삽입: 데이터를 저장할 수 있다. (중복 데이터 X)
- 탐색: 데이터가 저장됐는지 확인할 수 있다.
- 삭제: 저장한 데이터를 지울 수 있다.

```python
finished_classes = set()

# 데이터 저장
finished_classes.add("프로그래밍")
finished_classes.add("알고리즘")
finished_classes.add("자료 구조")

print(finished_classes) # 세트 출력

# 데이터 탐색
print("프로그래밍" in finished_classes)
print("알고리즘" in finished_classes)

# 데이터 삭제
finished_classes.remove("프로그래밍")
finished_classes.remove("알고리즘")
```

<br>

|      | 해시 테이블 |
| ---- | ----------- |
| 삽입 | O(1)        |
| 탐색 | O(1)        |
| 삭제 | O(1)        |
