# 1. Static Array & Dynamic Array

## 배열

배열은 어떤 자료의 집합이며 컴퓨터 자료구조에서 가장 간단한 자료구조 중 하나이다. <br>
배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로 하나 이상의 인덱스 또는 키로 식별된다. <br>
배열에는 크기를 지정하고 선언하는 **정적 배열(Static Array)** 과 배열의 크기를 유동적으로 조절할 수 있는 **동적 배열(Dynamic Array)** 이 있다.
<br><br>

## Static Array

크기를 정해놓고 정해진 크기 이상 값을 추가 또는 삭제할 수 없다. <br>
배열은 고정된 크기만큼의 연속된 메모리 할당이다. <br>
크기를 정해놓기 때문에 작은 영역을 할당하여 모자라거나 많은 영역을 할당하여 낭비되는 것을 해결하기 위해 동적 배열이 등장했다.
<br><br>

## Dynamic Array

정적 배열과 반대로 값을 추가하고 삭제할 수 있다. <br>
영역이 모자라거나 크기에 비해 많은 영역을 차지하고 있다면 자동으로 새로운 배열을 만들어 늘려주거나 줄여준다.
<br><br>

## 요약

### 연산 & 시간 복잡도

|               | 배열 | 동적배열         |
| ------------- | ---- | ---------------- |
| 접근 (access) | O(1) | O(1)             |
| 탐색 (search) | O(n) | O(n)             |
| 삽입 (insert) | N/A  | O(n), 맨 뒤 O(1) |
| 삭제 (delete) | N/A  | O(n), 맨 뒤 O(1) |

<br>
n : 배열에 들어가 있는 요소 수 <br>
접근(access) : 원하는 인덱스의 데이터를 가져오거나 바꾸는 연산 <br>
탐색(search) : 배열 안에서 특정 조건을 만족하는 데이터를 찾는 연산 <br>
삽입(insert) : 새로운 데이터를 추가<br>
삭제(delete) : 기존 데이터를 삭제<br>
O(n), O(1) : 시간 복잡도 
<br><br>

### 분할 상환 분석 (Amortized Analysis)

추가 연산 시간 복잡도로 예를 들어본다면 <br>
추가 시간에 대해 최고의 경우(O(1))와 최악의 경우(O(n))를 생각할 수 있다.<br>
시간 복잡도는 보수적으로 표현하기 위해 보통 최악의 경우로 생각한다. <br>
하지만 보통의 경우 배열이 꽉 차 있는 최악의 경우보다 배열이 비어있는 최고의 경우가 자주 일어나게 된다. <br>
그래서 동적배열에 값을 추가하는데 O(n)이 걸린다는 것은 비합리적이다. <br>
비합리적인 것을 해결하기 위해 시간 복잡도를 다르게 계산하는 몇 가지 방법 중 하나가 분할 상환 분석이다. <br>
분할 상환 분석은 쉽게 얘기해 할부 개념이다. <br>
같은 동작을 n번 했을 때 총 드는 시간이 X일 때, 동작을 한 번 하는데 걸린 시간은 X/n 라고 할 수 있다. <br>
즉, 분할 상환 분석은 시간 복잡도를 최악의 경우가 아닌 평균을 내는 개념이다.<br>
정리하자면 동적 배열의 추가(append)연산은 최악의 경우 O(n)이 걸리지만, 분할 상환 분석을 하면 O(1)이 걸린다.
<br><br>

### 낭비하는 공간

배열은 크기가 고정되어 있기 때문에 낭비하는 공간이 없다. 반면 동적 배열은 공간을 낭비할 수도 있고 안 할 수도 있다. 최악의 경우(새로운 배열을 만들었을 때)일 때 낭비되는 공간이 가장 많다. <br>
낭비되는 공간의 계산은 저장된 요소 수를 n이라 했을 때 n - 2로 계산하면 된다. <br>
즉, 낭비되는 공간은 최소 0 부터 최대 n-2 까지가 될 수 있다. (O(n))
