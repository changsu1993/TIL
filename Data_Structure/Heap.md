# 1. Heap (힙)

**조건**

- 형태 속성: 힙은 완전 이진 트리다.
- 힙 속성: 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다.

<br>

### 정렬

정렬이란 여러 개의 데이터 요소들을 특정 순서로 배치하는 것을 말한다.

```python
# 파이썬 리스트
[4, 1, 6, 2, 8, 5]

# 오름차순 정렬
[1, 2, 4, 5, 6, 8]

# 내림차순 정렬
[8, 6, 5, 4, 2, 1]
```

정렬 알고리즘: 데이터를 재배치하는 구체적인 방법

가장 흔한 정렬 알고리즘들 중에서는 삽입 정렬, 선택 정렬, 퀵 정렬, 합병 정렬 등이 있다.

<br>

**배열로 구현한 힙**

힙은 완전 이진 트리이기 때문에 보통 동적 배열로 나타낸다. <br>

<br>

**힙 만들기**

힙을 만들기 위해서는 형태 속성과 힙 속성의 조건을 만족해야 한다. <br>
힙 속성이 지켜지지 않을 때에는 heapify 알고리즘을 통해 해결할 수 있다. <br>
heapify는 파라미터로 어떤 노드 하나를 받는다. 이 노드를 부모 노드로 지정하고 <br>
부모 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 걸 고른다. <br>
가장 큰 노드가 부모 노드가 아니라면 가장 큰 노드와 부모 노드를 바꿔준다. <br>
부모 노드가 가장 크면 아무것도 하지 않고, 기존의 부모 노드가 밑으로 갔다면 또 힙 속성을 어길 수도 있다. <br>
이럴 경우 힙 속성이 충족될 때까지 반복한다. <br>
heapify 알고리즘을 쓰면 원하는 노드를 힙 속성에 맞는 위치로 재배치 시킬 수 있다. <br>

시간 복잡도 <br>
트리에 저장되어 있는 노드의 개수를 n이라 하고, <br>
최악의 경우 <br>
이 노드는 총 트리의 높이만큼 데이터를 비교하고 재배치 시킨다. 힙은 완전 이진 트리이기 때문에 높이가 O(log(n))이다. <br>
따라서 최악의 경우 heapify에 걸리는 시간은 O(log(n))에 비례한다. 그렇기 때문에 시간 복잡도도 O(log(n))이다. <br>
힙을 만들려면 heapify를 n개의 노드에 모두 호출해야 하므로 O(log(n))이 n번 걸린다. <br>
log(n) x n = n log(n) 이므로 힙을 만드는 데 걸리는 시간 복잡도는 O(n log(n))이다.

<br>

**힙 정렬**

힙을 이용한 정렬 알고리즘

- 힙을 만든다.
- root와 마지막 노드를 바꿔준다.(바꾼 노드는 없는 노드 취급한다.)
- 새로운 노드가 힙 속성을 지킬 수 있게 heapify 호출한다.
- 힙에 남아있는 노드가 없도록 단계 2 ~ 3을 반복한다.

1번째 단계인 리스트를 힙으로 만드는 데 걸리는 시간은 O(n log(n))이다. <br>
2번째 단계는 그냥 두 노드의 위치를 바꿔 주는 작업이기 때문에 노드의 개수 n과는 상관없이 항상 O(1)이다. <br>
3번째 단계는 새로운 root 노드에 heapify를 하니까 시간 복잡도는 O(log(n))이다. 2번째 단계와 3번째 단계를 합치면 O(log(n)+1) 즉, O(log(n))이다. <br>
4번째 단계는 2~3 단계를 반복한다. 힙에는 총 n개의 노드가 있으므로 2, 3, 4단계의 시간 복잡도를 종합하면 O(n log(n))이다. <br>

정리하면

- 힙을 만드는 데 O(n log(n))
- 만든 힙에서 매번 root 노드를 뽑고 남은 것들을 다시 힙으로 만들어주는 작업을 반복하는 데 O(n log(n))이 걸린다.

그럼 힙 정렬의 총 시간 복잡도는 O(n log(n)+n log(n))으로 O(2n log(n))이고, 시간 복잡도에서 상수는 무시되니까 결국 O(n log(n))이라고 할 수 있다. <br>
힙 정렬은 O(n log(n))의 시간 복잡도를 가지는 정렬 알고리즘인 것이다.

<br>

**다른 정렬 알고리즘들과의 비교**

| 정렬 알고리즘 | 시간 복잡도                        |
| ------------- | ---------------------------------- |
| 선택 정렬     | $O(n^2)$                           |
| 삽입 정렬     | $O(n^2)$                           |
| 합병 정렬     | $O(n log(n))$                      |
| 퀵 정렬       | 평균 $O(n log(n))$ (최악 $O(n^2)$) |
| 힙 정렬       | $O(n log(n))$                      |

힙 정렬은 선택 정렬과 삽입 정렬 ($O(n^2)$)보다는 좋고, 합병 정렬과 퀵 정렬 ($O(n log(n))$)과는 비슷한 성능을 내는 정렬 방법이다.

<br>

**우선순위 큐**

힙은 우선순위 큐 추상 자료형을 효율적으로 구현할 수 있다. <br>
우선순위 큐는 큐나 스택처럼 추상 자료형이다.

- 데이터를 저장할 수 있다.
- 저장한 데이터가 우선순위 순서대로 나온다.

<br>

**힙에 데이터 삽입하기** <br>

- 힙의 마지막 인덱스에 데이터를 삽입한다.
- 삽입한 데이터와 부모 노드의 데이터를 비교한다.
- 부모 노드의 데이터가 더 작으면 둘의 위치를 바꿔준다.
